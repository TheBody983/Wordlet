{"version":3,"file":"sdk-resolve-signatures.js","sources":["../src/index.js"],"sourcesContent":["import {isTransaction} from \"@onflow/interaction\"\nimport {\n  encodeTransactionPayload as encodeInsideMessage,\n  encodeTransactionEnvelope as encodeOutsideMessage,\n} from \"@onflow/encode\"\nimport {sansPrefix} from \"@onflow/util-address\"\n\nfunction prepForEncoding(ix) {\n  return {\n    script: ix.message.cadence,\n    refBlock: ix.message.refBlock || null,\n    gasLimit: ix.message.computeLimit,\n    arguments: ix.message.arguments.map(cid => ix.arguments[cid].asArgument),\n    proposalKey: {\n      address: sansPrefix(ix.accounts[ix.proposer].addr),\n      keyId: ix.accounts[ix.proposer].keyId,\n      sequenceNum: ix.accounts[ix.proposer].sequenceNum,\n    },\n    payer: sansPrefix(ix.accounts[ix.payer].addr),\n    authorizers: ix.authorizations\n      .map(cid => sansPrefix(ix.accounts[cid].addr))\n      .reduce((prev, current) => {\n        return prev.find(item => item === current)\n          ? prev\n          : [...prev, current]\n      }, []),\n  }\n}\n\nasync function fetchSignatures(ix, signers = [], message) {\n  return Promise.all(\n    signers.map(async cid => {\n      const compSig = await ix.accounts[cid].signingFunction({\n        message,\n        addr: sansPrefix(ix.accounts[cid].addr),\n        keyId: ix.accounts[cid].keyId,\n        roles: ix.accounts[cid].role, // grr this should be roles,\n        interaction: ix,\n      })\n      compSig.cid = cid\n      if (sansPrefix(ix.accounts[cid].addr) !== sansPrefix(compSig.addr)) {\n        throw new Error(`${cid} — mismatching address in composite signature`)\n      }\n      if (ix.accounts[cid].keyId !== compSig.keyId) {\n        throw new Error(`${cid} — mismatching keyId in composite signature`)\n      }\n      compSig.sig = compSig.signature\n      compSig.address = sansPrefix(compSig.addr)\n      return compSig\n    })\n  )\n}\n\nfunction collateSigners(ix) {\n  // inside signers are: (authorizers + proposer) - payer\n  let insideSigners = new Set(ix.authorizations)\n  insideSigners.add(ix.proposer)\n  insideSigners.delete(ix.payer)\n  insideSigners = Array.from(insideSigners)\n\n  // outside signers are: payer\n  let outsideSigners = new Set([ix.payer])\n  outsideSigners = Array.from(outsideSigners)\n\n  return {insideSigners, outsideSigners}\n}\n\nfunction mutateAccountsWithSignatures(ix, compSigs) {\n  for (let {cid, signature} of compSigs) {\n    ix.accounts[cid].signature = signature\n  }\n  return compSigs\n}\n\nexport async function resolveSignatures(ix) {\n  if (!isTransaction(ix)) return ix\n\n  const {insideSigners, outsideSigners} = collateSigners(ix)\n\n  // Get inside composite signatures for inside payload in parallel\n  const insideSignatures = mutateAccountsWithSignatures(\n    ix,\n    await fetchSignatures(\n      ix,\n      insideSigners,\n      encodeInsideMessage(prepForEncoding(ix))\n    )\n  )\n\n  // Get outside composite signatures for outside payload in parallel\n  const outsideSignatures = mutateAccountsWithSignatures(\n    ix,\n    await fetchSignatures(\n      ix,\n      outsideSigners,\n      encodeOutsideMessage({\n        ...prepForEncoding(ix),\n        payloadSigs: insideSignatures,\n      })\n    )\n  )\n\n  return ix\n}\n\n// TODO — WHAT WE WANT INSTEAD OF WHAT WE HAVE\n//\n// encodeInsideMessage({\n//   cadence: ___,\n//   refBlock: ___,\n//   computeLimit: ___,\n//   proposer: {\n//     addr: ___,\n//     keyId: ___,\n//     sequenceNum: __,\n//   },\n//   payer: ___,\n//   authorizers: [___],\n// })\n//\n// encodeInsideMessage({\n//   ...ix.message,\n//   proposer: ix.accounts[ix.proposer],\n//   payer: ix.accounts[ix.payer].addr,\n//   authorizers: ix.authorizers.map(cid => ix.accounts[cid].addr)\n// })\n//\n// encodeOutsideMessage({\n//   cadence: ___,\n//   refBlock: ___,\n//   computeLimit: ___,\n//   proposer: {\n//     addr: ___,\n//     keyId: ___,\n//     sequenceNum: __,\n//   },\n//   payer: ___,\n//   authorizers: [___],\n//   payloadSigs: [{ addr, keyId, signature }],\n// })\n//\n// encodeOutsideMessage({\n//   ...ix.message,\n//   proposer: ix.accounts[ix.proposer],\n//   payer: ix.accounts[ix.payer].addr,\n//   authorizers: ix.authorizers.map(cid => ix.accounts[cid].addr),\n//   payloadSigs: insideSignatures,\n// })\n"],"names":["prepForEncoding","ix","script","message","cadence","refBlock","gasLimit","computeLimit","arguments","map","cid","asArgument","proposalKey","address","sansPrefix","accounts","proposer","addr","keyId","sequenceNum","payer","authorizers","authorizations","reduce","prev","current","find","item","resolveSignatures","fetchSignatures","signers","Promise","all","signingFunction","roles","role","interaction","compSig","Error","sig","signature","mutateAccountsWithSignatures","compSigs","isTransaction","insideSigners","Set","add","Array","from","outsideSigners","collateSigners","encodeInsideMessage","insideSignatures","encodeOutsideMessage","payloadSigs"],"mappings":"4ZAOA,SAASA,EAAgBC,GACvB,MAAO,CACLC,OAAQD,EAAGE,QAAQC,QACnBC,SAAUJ,EAAGE,QAAQE,UAAY,KACjCC,SAAUL,EAAGE,QAAQI,aACrBC,UAAWP,EAAGE,QAAQK,UAAUC,IAAI,SAAAC,UAAOT,EAAGO,UAAUE,GAAKC,aAC7DC,YAAa,CACXC,QAASC,aAAWb,EAAGc,SAASd,EAAGe,UAAUC,MAC7CC,MAAOjB,EAAGc,SAASd,EAAGe,UAAUE,MAChCC,YAAalB,EAAGc,SAASd,EAAGe,UAAUG,aAExCC,MAAON,aAAWb,EAAGc,SAASd,EAAGmB,OAAOH,MACxCI,YAAapB,EAAGqB,eACbb,IAAI,SAAAC,UAAOI,aAAWb,EAAGc,SAASL,GAAKO,QACvCM,OAAO,SAACC,EAAMC,GACb,OAAOD,EAAKE,KAAK,SAAAC,UAAQA,IAASF,IAC9BD,YACIA,GAAMC,KACb,KAiDaG,IA7CPC,WAAgB5B,EAAI6B,EAAc3B,YAAd2B,IAAAA,EAAU,QAC3C,OAAOC,QAAQC,IACbF,EAAQrB,aAAUC,8BACMT,EAAGc,SAASL,GAAKuB,gBAAgB,CACrD9B,QAAAA,EACAc,KAAMH,aAAWb,EAAGc,SAASL,GAAKO,MAClCC,MAAOjB,EAAGc,SAASL,GAAKQ,MACxBgB,MAAOjC,EAAGc,SAASL,GAAKyB,KACxBC,YAAanC,mBALToC,GAQN,GADAA,EAAQ3B,IAAMA,EACVI,aAAWb,EAAGc,SAASL,GAAKO,QAAUH,aAAWuB,EAAQpB,MAC3D,UAAUqB,MAAS5B,mDAErB,GAAIT,EAAGc,SAASL,GAAKQ,QAAUmB,EAAQnB,MACrC,UAAUoB,MAAS5B,iDAIrB,OAFA2B,EAAQE,IAAMF,EAAQG,UACtBH,EAAQxB,QAAUC,aAAWuB,EAAQpB,MAC9BoB,IAjBT,0EAoCJ,SAASI,EAA6BxC,EAAIyC,GACxC,+rBAA6BA,kBAAU,eACrCzC,EAAGc,WADKL,KACS8B,YADJA,UAGf,OAAOE,qCAG+BzC,OACtC,IAAK0C,gBAAc1C,GAAK,uBAAOA,GADW,MArB5C,SAAwBA,GAEtB,IAAI2C,EAAgB,IAAIC,IAAI5C,EAAGqB,gBAC/BsB,EAAcE,IAAI7C,EAAGe,UACrB4B,SAAqB3C,EAAGmB,OACxBwB,EAAgBG,MAAMC,KAAKJ,GAG3B,IAAIK,EAAiB,IAAIJ,IAAI,CAAC5C,EAAGmB,QAGjC,MAAO,CAACwB,cAAAA,EAAeK,eAFvBA,EAAiBF,MAAMC,KAAKC,IAeYC,CAAejD,GAAjCgD,IAAAA,sCAKdpB,EACJ5B,IANG2C,cAQHO,2BAAoBnD,EAAgBC,uBALxC,IAAMmD,EAAmBX,EACvBxC,KAPwC,uBAkBlC4B,EACJ5B,EACAgD,EACAI,iCACKrD,EAAgBC,IACnBqD,YAAaF,wBAKnB,OAZ0BX,EACxBxC,KAWKA,MA5BT"}