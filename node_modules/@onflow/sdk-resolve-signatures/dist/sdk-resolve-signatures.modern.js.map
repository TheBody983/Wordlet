{"version":3,"file":"sdk-resolve-signatures.modern.js","sources":["../src/index.js"],"sourcesContent":["import {isTransaction} from \"@onflow/interaction\"\nimport {\n  encodeTransactionPayload as encodeInsideMessage,\n  encodeTransactionEnvelope as encodeOutsideMessage,\n} from \"@onflow/encode\"\nimport {sansPrefix} from \"@onflow/util-address\"\n\nfunction prepForEncoding(ix) {\n  return {\n    script: ix.message.cadence,\n    refBlock: ix.message.refBlock || null,\n    gasLimit: ix.message.computeLimit,\n    arguments: ix.message.arguments.map(cid => ix.arguments[cid].asArgument),\n    proposalKey: {\n      address: sansPrefix(ix.accounts[ix.proposer].addr),\n      keyId: ix.accounts[ix.proposer].keyId,\n      sequenceNum: ix.accounts[ix.proposer].sequenceNum,\n    },\n    payer: sansPrefix(ix.accounts[ix.payer].addr),\n    authorizers: ix.authorizations\n      .map(cid => sansPrefix(ix.accounts[cid].addr))\n      .reduce((prev, current) => {\n        return prev.find(item => item === current)\n          ? prev\n          : [...prev, current]\n      }, []),\n  }\n}\n\nasync function fetchSignatures(ix, signers = [], message) {\n  return Promise.all(\n    signers.map(async cid => {\n      const compSig = await ix.accounts[cid].signingFunction({\n        message,\n        addr: sansPrefix(ix.accounts[cid].addr),\n        keyId: ix.accounts[cid].keyId,\n        roles: ix.accounts[cid].role, // grr this should be roles,\n        interaction: ix,\n      })\n      compSig.cid = cid\n      if (sansPrefix(ix.accounts[cid].addr) !== sansPrefix(compSig.addr)) {\n        throw new Error(`${cid} — mismatching address in composite signature`)\n      }\n      if (ix.accounts[cid].keyId !== compSig.keyId) {\n        throw new Error(`${cid} — mismatching keyId in composite signature`)\n      }\n      compSig.sig = compSig.signature\n      compSig.address = sansPrefix(compSig.addr)\n      return compSig\n    })\n  )\n}\n\nfunction collateSigners(ix) {\n  // inside signers are: (authorizers + proposer) - payer\n  let insideSigners = new Set(ix.authorizations)\n  insideSigners.add(ix.proposer)\n  insideSigners.delete(ix.payer)\n  insideSigners = Array.from(insideSigners)\n\n  // outside signers are: payer\n  let outsideSigners = new Set([ix.payer])\n  outsideSigners = Array.from(outsideSigners)\n\n  return {insideSigners, outsideSigners}\n}\n\nfunction mutateAccountsWithSignatures(ix, compSigs) {\n  for (let {cid, signature} of compSigs) {\n    ix.accounts[cid].signature = signature\n  }\n  return compSigs\n}\n\nexport async function resolveSignatures(ix) {\n  if (!isTransaction(ix)) return ix\n\n  const {insideSigners, outsideSigners} = collateSigners(ix)\n\n  // Get inside composite signatures for inside payload in parallel\n  const insideSignatures = mutateAccountsWithSignatures(\n    ix,\n    await fetchSignatures(\n      ix,\n      insideSigners,\n      encodeInsideMessage(prepForEncoding(ix))\n    )\n  )\n\n  // Get outside composite signatures for outside payload in parallel\n  const outsideSignatures = mutateAccountsWithSignatures(\n    ix,\n    await fetchSignatures(\n      ix,\n      outsideSigners,\n      encodeOutsideMessage({\n        ...prepForEncoding(ix),\n        payloadSigs: insideSignatures,\n      })\n    )\n  )\n\n  return ix\n}\n\n// TODO — WHAT WE WANT INSTEAD OF WHAT WE HAVE\n//\n// encodeInsideMessage({\n//   cadence: ___,\n//   refBlock: ___,\n//   computeLimit: ___,\n//   proposer: {\n//     addr: ___,\n//     keyId: ___,\n//     sequenceNum: __,\n//   },\n//   payer: ___,\n//   authorizers: [___],\n// })\n//\n// encodeInsideMessage({\n//   ...ix.message,\n//   proposer: ix.accounts[ix.proposer],\n//   payer: ix.accounts[ix.payer].addr,\n//   authorizers: ix.authorizers.map(cid => ix.accounts[cid].addr)\n// })\n//\n// encodeOutsideMessage({\n//   cadence: ___,\n//   refBlock: ___,\n//   computeLimit: ___,\n//   proposer: {\n//     addr: ___,\n//     keyId: ___,\n//     sequenceNum: __,\n//   },\n//   payer: ___,\n//   authorizers: [___],\n//   payloadSigs: [{ addr, keyId, signature }],\n// })\n//\n// encodeOutsideMessage({\n//   ...ix.message,\n//   proposer: ix.accounts[ix.proposer],\n//   payer: ix.accounts[ix.payer].addr,\n//   authorizers: ix.authorizers.map(cid => ix.accounts[cid].addr),\n//   payloadSigs: insideSignatures,\n// })\n"],"names":["prepForEncoding","ix","script","message","cadence","refBlock","gasLimit","computeLimit","arguments","map","cid","asArgument","proposalKey","address","sansPrefix","accounts","proposer","addr","keyId","sequenceNum","payer","authorizers","authorizations","reduce","prev","current","find","item","async","fetchSignatures","signers","Promise","all","compSig","signingFunction","roles","role","interaction","Error","sig","signature","mutateAccountsWithSignatures","compSigs","resolveSignatures","isTransaction","insideSigners","outsideSigners","Set","add","delete","Array","from","collateSigners","insideSignatures","encodeInsideMessage","encodeOutsideMessage","payloadSigs"],"mappings":"8YAOA,SAASA,EAAgBC,GACvB,MAAO,CACLC,OAAQD,EAAGE,QAAQC,QACnBC,SAAUJ,EAAGE,QAAQE,UAAY,KACjCC,SAAUL,EAAGE,QAAQI,aACrBC,UAAWP,EAAGE,QAAQK,UAAUC,IAAIC,GAAOT,EAAGO,UAAUE,GAAKC,YAC7DC,YAAa,CACXC,QAASC,EAAWb,EAAGc,SAASd,EAAGe,UAAUC,MAC7CC,MAAOjB,EAAGc,SAASd,EAAGe,UAAUE,MAChCC,YAAalB,EAAGc,SAASd,EAAGe,UAAUG,aAExCC,MAAON,EAAWb,EAAGc,SAASd,EAAGmB,OAAOH,MACxCI,YAAapB,EAAGqB,eACbb,IAAIC,GAAOI,EAAWb,EAAGc,SAASL,GAAKO,OACvCM,OAAO,CAACC,EAAMC,IACND,EAAKE,KAAKC,GAAQA,IAASF,GAC9BD,EACA,IAAIA,EAAMC,GACb,KAITG,eAAeC,EAAgB5B,EAAI6B,EAAU,GAAI3B,GAC/C,OAAO4B,QAAQC,IACbF,EAAQrB,IAAImB,MAAAA,IACV,MAAMK,QAAgBhC,EAAGc,SAASL,GAAKwB,gBAAgB,CACrD/B,QAAAA,EACAc,KAAMH,EAAWb,EAAGc,SAASL,GAAKO,MAClCC,MAAOjB,EAAGc,SAASL,GAAKQ,MACxBiB,MAAOlC,EAAGc,SAASL,GAAK0B,KACxBC,YAAapC,IAGf,GADAgC,EAAQvB,IAAMA,EACVI,EAAWb,EAAGc,SAASL,GAAKO,QAAUH,EAAWmB,EAAQhB,MAC3D,UAAUqB,MAAS5B,EAAF,iDAEnB,GAAIT,EAAGc,SAASL,GAAKQ,QAAUe,EAAQf,MACrC,UAAUoB,MAAS5B,EAAF,+CAInB,OAFAuB,EAAQM,IAAMN,EAAQO,UACtBP,EAAQpB,QAAUC,EAAWmB,EAAQhB,MAC9BgB,KAmBb,SAASQ,EAA6BxC,EAAIyC,GACxC,IAAK,IAAIhC,IAACA,EAAD8B,UAAMA,KAAcE,EAC3BzC,EAAGc,SAASL,GAAK8B,UAAYA,EAE/B,OAAOE,iBAGaC,EAAkB1C,GACtC,IAAK2C,EAAc3C,GAAK,OAAOA,EAE/B,MAAM4C,cAACA,EAADC,eAAgBA,GAxBxB,SAAwB7C,GAEtB,IAAI4C,EAAgB,IAAIE,IAAI9C,EAAGqB,gBAC/BuB,EAAcG,IAAI/C,EAAGe,UACrB6B,EAAcI,OAAOhD,EAAGmB,OACxByB,EAAgBK,MAAMC,KAAKN,GAG3B,IAAIC,EAAiB,IAAIC,IAAI,CAAC9C,EAAGmB,QAGjC,OAFA0B,EAAiBI,MAAMC,KAAKL,GAErB,CAACD,cAAAA,EAAeC,eAAAA,GAaiBM,CAAenD,GAGjDoD,EAAmBZ,EACvBxC,QACM4B,EACJ5B,EACA4C,EACAS,EAAoBtD,EAAgBC,MAiBxC,OAZ0BwC,EACxBxC,QACM4B,EACJ5B,EACA6C,EACAS,OACKvD,EAAgBC,IACnBuD,YAAaH,OAKZpD"}