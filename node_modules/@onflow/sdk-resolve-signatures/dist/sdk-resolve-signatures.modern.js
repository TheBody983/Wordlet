import{isTransaction as r}from"@onflow/interaction";import{encodeTransactionPayload as e,encodeTransactionEnvelope as n}from"@onflow/encode";import{sansPrefix as t}from"@onflow/util-address";function a(){return(a=Object.assign||function(r){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(r[t]=n[t])}return r}).apply(this,arguments)}function o(r){return{script:r.message.cadence,refBlock:r.message.refBlock||null,gasLimit:r.message.computeLimit,arguments:r.message.arguments.map(e=>r.arguments[e].asArgument),proposalKey:{address:t(r.accounts[r.proposer].addr),keyId:r.accounts[r.proposer].keyId,sequenceNum:r.accounts[r.proposer].sequenceNum},payer:t(r.accounts[r.payer].addr),authorizers:r.authorizations.map(e=>t(r.accounts[e].addr)).reduce((r,e)=>r.find(r=>r===e)?r:[...r,e],[])}}async function s(r,e=[],n){return Promise.all(e.map(async e=>{const a=await r.accounts[e].signingFunction({message:n,addr:t(r.accounts[e].addr),keyId:r.accounts[e].keyId,roles:r.accounts[e].role,interaction:r});if(a.cid=e,t(r.accounts[e].addr)!==t(a.addr))throw new Error(e+" — mismatching address in composite signature");if(r.accounts[e].keyId!==a.keyId)throw new Error(e+" — mismatching keyId in composite signature");return a.sig=a.signature,a.address=t(a.addr),a}))}function i(r,e){for(let{cid:n,signature:t}of e)r.accounts[n].signature=t;return e}async function c(t){if(!r(t))return t;const{insideSigners:c,outsideSigners:u}=function(r){let e=new Set(r.authorizations);e.add(r.proposer),e.delete(r.payer),e=Array.from(e);let n=new Set([r.payer]);return n=Array.from(n),{insideSigners:e,outsideSigners:n}}(t),d=i(t,await s(t,c,e(o(t))));return i(t,await s(t,u,n(a({},o(t),{payloadSigs:d})))),t}export{c as resolveSignatures};
//# sourceMappingURL=sdk-resolve-signatures.modern.js.map
