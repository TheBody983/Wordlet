{"version":3,"file":"sdk-resolve-signatures.module.js","sources":["../src/index.js"],"sourcesContent":["import {isTransaction} from \"@onflow/interaction\"\nimport {\n  encodeTransactionPayload as encodeInsideMessage,\n  encodeTransactionEnvelope as encodeOutsideMessage,\n} from \"@onflow/encode\"\nimport {sansPrefix} from \"@onflow/util-address\"\n\nfunction prepForEncoding(ix) {\n  return {\n    script: ix.message.cadence,\n    refBlock: ix.message.refBlock || null,\n    gasLimit: ix.message.computeLimit,\n    arguments: ix.message.arguments.map(cid => ix.arguments[cid].asArgument),\n    proposalKey: {\n      address: sansPrefix(ix.accounts[ix.proposer].addr),\n      keyId: ix.accounts[ix.proposer].keyId,\n      sequenceNum: ix.accounts[ix.proposer].sequenceNum,\n    },\n    payer: sansPrefix(ix.accounts[ix.payer].addr),\n    authorizers: ix.authorizations\n      .map(cid => sansPrefix(ix.accounts[cid].addr))\n      .reduce((prev, current) => {\n        return prev.find(item => item === current)\n          ? prev\n          : [...prev, current]\n      }, []),\n  }\n}\n\nasync function fetchSignatures(ix, signers = [], message) {\n  return Promise.all(\n    signers.map(async cid => {\n      const compSig = await ix.accounts[cid].signingFunction({\n        message,\n        addr: sansPrefix(ix.accounts[cid].addr),\n        keyId: ix.accounts[cid].keyId,\n        roles: ix.accounts[cid].role, // grr this should be roles,\n        interaction: ix,\n      })\n      compSig.cid = cid\n      if (sansPrefix(ix.accounts[cid].addr) !== sansPrefix(compSig.addr)) {\n        throw new Error(`${cid} — mismatching address in composite signature`)\n      }\n      if (ix.accounts[cid].keyId !== compSig.keyId) {\n        throw new Error(`${cid} — mismatching keyId in composite signature`)\n      }\n      compSig.sig = compSig.signature\n      compSig.address = sansPrefix(compSig.addr)\n      return compSig\n    })\n  )\n}\n\nfunction collateSigners(ix) {\n  // inside signers are: (authorizers + proposer) - payer\n  let insideSigners = new Set(ix.authorizations)\n  insideSigners.add(ix.proposer)\n  insideSigners.delete(ix.payer)\n  insideSigners = Array.from(insideSigners)\n\n  // outside signers are: payer\n  let outsideSigners = new Set([ix.payer])\n  outsideSigners = Array.from(outsideSigners)\n\n  return {insideSigners, outsideSigners}\n}\n\nfunction mutateAccountsWithSignatures(ix, compSigs) {\n  for (let {cid, signature} of compSigs) {\n    ix.accounts[cid].signature = signature\n  }\n  return compSigs\n}\n\nexport async function resolveSignatures(ix) {\n  if (!isTransaction(ix)) return ix\n\n  const {insideSigners, outsideSigners} = collateSigners(ix)\n\n  // Get inside composite signatures for inside payload in parallel\n  const insideSignatures = mutateAccountsWithSignatures(\n    ix,\n    await fetchSignatures(\n      ix,\n      insideSigners,\n      encodeInsideMessage(prepForEncoding(ix))\n    )\n  )\n\n  // Get outside composite signatures for outside payload in parallel\n  const outsideSignatures = mutateAccountsWithSignatures(\n    ix,\n    await fetchSignatures(\n      ix,\n      outsideSigners,\n      encodeOutsideMessage({\n        ...prepForEncoding(ix),\n        payloadSigs: insideSignatures,\n      })\n    )\n  )\n\n  return ix\n}\n\n// TODO — WHAT WE WANT INSTEAD OF WHAT WE HAVE\n//\n// encodeInsideMessage({\n//   cadence: ___,\n//   refBlock: ___,\n//   computeLimit: ___,\n//   proposer: {\n//     addr: ___,\n//     keyId: ___,\n//     sequenceNum: __,\n//   },\n//   payer: ___,\n//   authorizers: [___],\n// })\n//\n// encodeInsideMessage({\n//   ...ix.message,\n//   proposer: ix.accounts[ix.proposer],\n//   payer: ix.accounts[ix.payer].addr,\n//   authorizers: ix.authorizers.map(cid => ix.accounts[cid].addr)\n// })\n//\n// encodeOutsideMessage({\n//   cadence: ___,\n//   refBlock: ___,\n//   computeLimit: ___,\n//   proposer: {\n//     addr: ___,\n//     keyId: ___,\n//     sequenceNum: __,\n//   },\n//   payer: ___,\n//   authorizers: [___],\n//   payloadSigs: [{ addr, keyId, signature }],\n// })\n//\n// encodeOutsideMessage({\n//   ...ix.message,\n//   proposer: ix.accounts[ix.proposer],\n//   payer: ix.accounts[ix.payer].addr,\n//   authorizers: ix.authorizers.map(cid => ix.accounts[cid].addr),\n//   payloadSigs: insideSignatures,\n// })\n"],"names":["prepForEncoding","ix","script","message","cadence","refBlock","gasLimit","computeLimit","arguments","map","cid","asArgument","proposalKey","address","sansPrefix","accounts","proposer","addr","keyId","sequenceNum","payer","authorizers","authorizations","reduce","prev","current","find","item","resolveSignatures","isTransaction","insideSigners","Set","add","Array","from","outsideSigners","collateSigners","fetchSignatures","encodeInsideMessage","insideSignatures","mutateAccountsWithSignatures","encodeOutsideMessage","payloadSigs","signers","Promise","all","signingFunction","roles","role","interaction","compSig","Error","sig","signature","compSigs"],"mappings":"wfAOA,SAASA,EAAgBC,GACvB,MAAO,CACLC,OAAQD,EAAGE,QAAQC,QACnBC,SAAUJ,EAAGE,QAAQE,UAAY,KACjCC,SAAUL,EAAGE,QAAQI,aACrBC,UAAWP,EAAGE,QAAQK,UAAUC,IAAI,SAAAC,UAAOT,EAAGO,UAAUE,GAAKC,aAC7DC,YAAa,CACXC,QAASC,EAAWb,EAAGc,SAASd,EAAGe,UAAUC,MAC7CC,MAAOjB,EAAGc,SAASd,EAAGe,UAAUE,MAChCC,YAAalB,EAAGc,SAASd,EAAGe,UAAUG,aAExCC,MAAON,EAAWb,EAAGc,SAASd,EAAGmB,OAAOH,MACxCI,YAAapB,EAAGqB,eACbb,IAAI,SAAAC,UAAOI,EAAWb,EAAGc,SAASL,GAAKO,QACvCM,OAAO,SAACC,EAAMC,GACb,OAAOD,EAAKE,KAAK,SAAAC,UAAQA,IAASF,IAC9BD,YACIA,GAAMC,KACb,KAiDaG,IAAAA,WAAkB3B,OACtC,IAAK4B,EAAc5B,GAAK,uBAAOA,GADW,MArB5C,SAAwBA,GAEtB,IAAI6B,EAAgB,IAAIC,IAAI9B,EAAGqB,gBAC/BQ,EAAcE,IAAI/B,EAAGe,UACrBc,SAAqB7B,EAAGmB,OACxBU,EAAgBG,MAAMC,KAAKJ,GAG3B,IAAIK,EAAiB,IAAIJ,IAAI,CAAC9B,EAAGmB,QAGjC,MAAO,CAACU,cAAAA,EAAeK,eAFvBA,EAAiBF,MAAMC,KAAKC,IAeYC,CAAenC,GAAjCkC,IAAAA,sCAKdE,EACJpC,IANG6B,cAQHQ,EAAoBtC,EAAgBC,uBALxC,IAAMsC,EAAmBC,EACvBvC,KAPwC,uBAkBlCoC,EACJpC,EACAkC,EACAM,OACKzC,EAAgBC,IACnByC,YAAaH,wBAKnB,OAZ0BC,EACxBvC,KAWKA,MA5BT,oCA7CeoC,WAAgBpC,EAAI0C,EAAcxC,YAAdwC,IAAAA,EAAU,QAC3C,OAAOC,QAAQC,IACbF,EAAQlC,aAAUC,8BACMT,EAAGc,SAASL,GAAKoC,gBAAgB,CACrD3C,QAAAA,EACAc,KAAMH,EAAWb,EAAGc,SAASL,GAAKO,MAClCC,MAAOjB,EAAGc,SAASL,GAAKQ,MACxB6B,MAAO9C,EAAGc,SAASL,GAAKsC,KACxBC,YAAahD,mBALTiD,GAQN,GADAA,EAAQxC,IAAMA,EACVI,EAAWb,EAAGc,SAASL,GAAKO,QAAUH,EAAWoC,EAAQjC,MAC3D,UAAUkC,MAASzC,mDAErB,GAAIT,EAAGc,SAASL,GAAKQ,QAAUgC,EAAQhC,MACrC,UAAUiC,MAASzC,iDAIrB,OAFAwC,EAAQE,IAAMF,EAAQG,UACtBH,EAAQrC,QAAUC,EAAWoC,EAAQjC,MAC9BiC,IAjBT,0EAoCJ,SAASV,EAA6BvC,EAAIqD,GACxC,+rBAA6BA,kBAAU,eACrCrD,EAAGc,WADKL,KACS2C,YADJA,UAGf,OAAOC"}